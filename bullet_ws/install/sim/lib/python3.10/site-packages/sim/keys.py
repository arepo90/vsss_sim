import rclpy
from rclpy.node import Node
import sys
import termios
import tty
from select import select

# Import your custom message
from sim_msgs.msg import LowCmd

# Constants for linear and angular speeds
LIN_VEL_STEP_SIZE = 0.2  # m/s
ANG_VEL_STEP_SIZE = 10  # rad/s

# User instructions
msg = """
Control Your Robot!
---------------------------
Moving around:
        w
   a    s    d

q/e : increase/decrease angular velocity (dtheta)

space key, x : force stop
CTRL-C to quit
"""

def get_key(settings):
    """
    Reads a single character from the terminal.
    """
    if sys.platform == 'win32':
        # This function does not support Windows
        raise NotImplementedError("This script does not support Windows.")
    
    # Set terminal to raw mode
    tty.setraw(sys.stdin.fileno())
    
    # Check for input
    rlist, _, _ = select([sys.stdin], [], [], 0.1)
    
    key = ''
    if rlist:
        key = sys.stdin.read(1)
        
    # Restore terminal settings
    termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings)
    return key

class TeleopKeyboardNode(Node):
    """
    A ROS 2 node that translates keyboard strokes into sim_msgs/LowCmd messages.
    """
    def __init__(self):
        super().__init__('teleop_keyboard_node')
        
        # Store terminal settings
        self.settings = termios.tcgetattr(sys.stdin)
        
        # Create a publisher for the LowCmd topic
        self.publisher_ = self.create_publisher(LowCmd, 'low0', 10)
        
        # Initialize velocities and robot ID
        self.vx = 0.0
        self.vy = 0.0
        self.dtheta = 0.0
        self.robot_id = 0  # Default robot ID
        
        self.get_logger().info("Teleop Keyboard Node Started")
        print(msg)

        # Main control loop
        self.run_loop()

    def run_loop(self):
        """
        Continuously checks for keyboard input and publishes commands.
        """
        while rclpy.ok():
            key = get_key(self.settings)
            
            # Update velocities based on key press
            if key == 'w':
                self.vx = LIN_VEL_STEP_SIZE
                self.vy = 0.0
            elif key == 's':
                self.vx = -LIN_VEL_STEP_SIZE
                self.vy = 0.0
            elif key == 'a':
                self.vy = LIN_VEL_STEP_SIZE
                self.vx = 0.0
            elif key == 'd':
                self.vy = -LIN_VEL_STEP_SIZE
                self.vx = 0.0
            elif key == 'q':
                self.dtheta += ANG_VEL_STEP_SIZE
            elif key == 'e':
                self.dtheta -= ANG_VEL_STEP_SIZE
            elif key == ' ' or key == 'x':
                self.vx = 0.0
                self.vy = 0.0
                self.dtheta = 0.0
            elif not key: # If no key is pressed, robot should stop moving linearly
                self.vx = 0.0
                self.vy = 0.0

            # Create and publish the message
            low_cmd_msg = LowCmd()
            low_cmd_msg.robot_id = self.robot_id
            low_cmd_msg.vx = float(self.vx)
            low_cmd_msg.vy = float(self.vy)
            low_cmd_msg.dtheta = float(self.dtheta)
            
            self.publisher_.publish(low_cmd_msg)
            
            # Print current velocities for feedback
            self.print_status()

    def print_status(self):
        """
        Prints the current velocity status to the console.
        """
        sys.stdout.write(f"\rCurrent velocities: vx={self.vx:.2f}, vy={self.vy:.2f}, dtheta={self.dtheta:.2f}      ")
        sys.stdout.flush()

    def on_shutdown(self):
        """
        Restores terminal settings on node shutdown.
        """
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        self.get_logger().info("Teleop Keyboard Node Shutting Down")


def main(args=None):
    rclpy.init(args=args)
    node = TeleopKeyboardNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.on_shutdown()
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
import rclpy
from rclpy.node import Node
import cv2
from ultralytics import YOLO
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
import os
from ament_index_python.packages import get_package_share_directory
import torch
import numpy as np

NUM_ROBOTS = 2
MIN_AREA = 40
COLOR_RANGES = {
    "red": [(165, 100, 100), (180, 255, 255)],
    "orange": [(0, 100, 100), (20, 255, 255)],
    "yellow": [(20, 25, 25), (38, 255, 255)],
    "green": [(38, 50, 50), (85, 255, 255)],
    "light_blue": [(85, 100, 100), (105, 255, 255)],
    "blue": [(105, 50, 50), (130, 255, 255)], 
    "purple": [(130, 50, 50), (165, 255, 255)]
}

orange = np.load(os.path.join(get_package_share_directory('sim'), 'imgs', 'lut_orange.npy'))

class PatternRegistry:
    def __init__(self):
        self.next = 1
        self.seen = []

class Yolo(Node):
    def __init__(self):
        super().__init__('yolo')
        self.last_center = None
        self.cap = cv2.VideoCapture(2)
        self.H = np.array([
            [1.37815360e+00, 5.54951443e-03, -1.20929691e+02],
            [-2.28416795e-02, 9.55954974e-01, 5.12234601e+01],
            [-1.97069052e-05, -2.71718704e-05, 1.00000000e+00]
        ])
        if not self.cap.isOpened():
            self.get_logger().error(f"Failed to open video source: {2}")
            rclpy.shutdown()
            return
    
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
        self.cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 1) 
        self.cap.set(cv2.CAP_PROP_EXPOSURE, 400)

        try:
            device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')
            self.model = YOLO(os.path.join(get_package_share_directory('sim'), 'models', 'best.pt'))
            self.model.to(device)
        except Exception as e:
            self.get_logger().error(f"Failed to load YOLO model: {e}")
            rclpy.shutdown()
            return
            
        self.timer = self.create_timer(1.0/30.0, self.timer_callback)
        self.get_logger().info('YOLO Detector node has been started.')

    
    def ball_detection(self, img):
        frame = img.copy()
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        h, s, v = cv2.split(hsv)

        # Bajar brillo
        #v = np.clip(v - 40, 0, 255)

        #hsv_darker = cv2.merge([h, s, v])
        frame = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

        yuv = cv2.cvtColor(frame, cv2.COLOR_BGR2YUV)
        U = yuv[:, :, 1]
        V = yuv[:, :, 2]

        mask = orange[V, U]

        kernel_size = 10
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=1)
        mask = cv2.medianBlur(mask, 5)
        
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        cv2.imshow("orange mask", mask)
        
        possible_ellipses = []

        filtered_contours = [c for c in contours if cv2.contourArea(c) > 0]
        print(f"found {len(filtered_contours)} parsed contours")
        cv2.drawContours(frame, filtered_contours, -1, (255, 0, 255), 2)



        for cnt in contours:
            if len(cnt) >= 4: 
                area = cv2.contourArea(cnt)
                if area > 10 and area < 10000:  # se ajusta dependiendo del tamaÃ±o esperado
                    ellipse = cv2.fitEllipse(cnt)
                    possible_ellipses.append(ellipse)
                    
        chosen_ellipse = None

        if possible_ellipses:
            if self.last_center is None:
                chosen_ellipse = max(possible_ellipses, key=lambda e: np.pi * (e[1][0] / 2) * (e[1][1] / 2))
            else:
                def distance(e):
                    center = e[0]
                    return np.linalg.norm(np.array(center) - np.array(self.last_center))
                
                chosen_ellipse = min(possible_ellipses, key=distance)
            
        if chosen_ellipse is not None:
            cv2.ellipse(frame, chosen_ellipse, (0, 255, 0), 2)
            self.last_center = chosen_ellipse[0]
            (x, y) = self.last_center
            cv2.circle(frame, (int(x), int(y)), 5, (0, 0, 255), -1)
            self.get_logger().info("Ball center: " + str(self.last_center))
        else:
            self.last_center = None
            self.get_logger().info("Ball not detected")

        cv2.imshow("YES", frame)

    def timer_callback(self):
        _, frame = self.cap.read()
        frame = cv2.warpPerspective(frame, self.H, (frame.shape[1], frame.shape[0]))

        results = self.model(frame, verbose=False)
        self.ball_detection(frame)

        annotated_frame = results[0].plot()
        for i, box in enumerate(results[0].boxes):
            coords_tensor = box.xyxy[0]
            coords = [int(val) for val in coords_tensor.tolist()]
            x1, y1, x2, y2 = coords
            
            class_id = int(box.cls.item())
            class_name = self.model.names[class_id]
            confidence = box.conf.item()
            if confidence < 0.5:
                continue

            roi = frame[y1:y2, x1:x2]
            #robot = self.parseROI(roi)

            cv2.imshow(f"{class_name}{i}", roi)

        num_detections = len(results[0].boxes)
        self.get_logger().info(f"Detected {num_detections} objects.")

        cv2.imshow("frame", annotated_frame)
        cv2.waitKey(1)

    def parseROI(self, frame):
        hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        total = []
        flag = False
        for color, c_range in COLOR_RANGES.items():
            if color == "red":
                red_mask_low = cv2.inRange(hsv_frame, (0, 100, 100), (10, 255, 255))
                red_mask_high = cv2.inRange(hsv_frame, (165, 100, 100), (180, 255, 255))
                mask = cv2.bitwise_or(red_mask_low, red_mask_high)
            else:
                mask = cv2.inRange(hsv_frame, c_range[0], c_range[1])
        
            #cv2.imshow(f"mask {color}", mask)
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            filtered_contours = [c for c in contours if cv2.contourArea(c) > MIN_AREA]

            if len(filtered_contours) == 0:
                return []

            total.append({"color": color, "contours": filtered_contours})

    def destroy_node(self):
        self.cap.release()
        cv2.destroyAllWindows()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    yolo_detector_node = Yolo()
    try:
        rclpy.spin(yolo_detector_node)
    except KeyboardInterrupt:
        pass
    finally:
        # Destroy the node explicitly
        # (optional - Done automatically on shutdown)
        yolo_detector_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
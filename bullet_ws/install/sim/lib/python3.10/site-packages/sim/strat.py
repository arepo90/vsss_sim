import rclpy
import numpy as np
from rclpy.node import Node
from sim_msgs.msg import FieldData, LowCmd, ObjData, Settings

FIELD_LENGTH = 17
TEAM_GOAL = np.array([FIELD_LENGTH / 2, 0.0])
OP_GOAL = np.array([-FIELD_LENGTH / 2, 0.0])

ATTRACTIVE_GAIN = 0.5
REPULSIVE_GAIN = 3
REPULSION_RADIUS = 1
GOAL_TOLERANCE = 1
TANGENTIAL_GAIN = 3
MAX_LINEAR_SPEED = 3

class SkillLib:
    def moveToPoint(self, robot: ObjData, target_pos: np.ndarray, target_theta: float, obstacles: list[ObjData]) -> LowCmd:
        robot_pos = np.array([robot.x, robot.y])
        robot_vel = np.array([robot.vx, robot.vy])


        #vx_robot, vy_robot = self._calculate_potential_field_vector(robot_pos, robot_vel, target_pos, obstacles)
        net_vector = self._calculate_potential_field_vector(robot_pos, robot_vel, target_pos, obstacles)
        vx_robot, vy_robot = self._world_to_robot_frame(net_vector, robot.theta)
        
        vx_capped, vy_capped = self._cap_speed(vx_robot, vy_robot)

        cmd = LowCmd()
        cmd.robot_id = robot.obj_id
        cmd.vx = vx_capped
        cmd.vy = vy_capped
        #cmd.theta = target_theta + 180
        if abs(-robot.theta + target_theta) < (360 -robot.theta + target_theta) % 360:
            cmd.dtheta = -robot.theta + target_theta
        else:
            cmd.dtheta = (360 - robot.theta + target_theta) % 360

        return cmd
    
    def strikeBall(self, robot: ObjData, ball: ObjData, strike_target_pos: np.ndarray) -> LowCmd:
        vec_ball_to_target = strike_target_pos - np.array([ball.x, ball.y])
        
        drive_through_point = np.array([ball.x, ball.y]) + 0.1 * (vec_ball_to_target / np.linalg.norm(vec_ball_to_target))

        strike_theta = np.rad2deg(np.arctan2(vec_ball_to_target[1], vec_ball_to_target[0]) + 90)
        
        cmd = self.moveToPoint(robot, drive_through_point, strike_theta, obstacles=[])
        return cmd

    def _calculate_potential_field_vector(self, robot_pos: np.ndarray, robot_vel: np.ndarray, target_pos: np.ndarray, obstacles: list[ObjData]) -> np.ndarray:
        attractive_vector = ATTRACTIVE_GAIN * (target_pos - robot_pos)

        if np.linalg.norm(target_pos - robot_pos) < GOAL_TOLERANCE:
            return attractive_vector

        net_repulsive_vector = np.array([0.0, 0.0])
        for obs in obstacles:
            obs_pos = np.array([obs.x, obs.y])
            vec_to_robot = robot_pos - obs_pos
            dist_to_robot = np.linalg.norm(vec_to_robot)
            
            if dist_to_robot < REPULSION_RADIUS:
                repulsion_magnitude = REPULSIVE_GAIN * (1.0 / dist_to_robot - 1.0 / REPULSION_RADIUS)
                radial_repulsive_force = repulsion_magnitude * (vec_to_robot / dist_to_robot)
                vec_robot_to_goal = target_pos - robot_pos
                tangential_dir = np.array([-vec_robot_to_goal[1], vec_robot_to_goal[0]])
                if np.dot(tangential_dir, vec_to_robot) < 0:
                    tangential_dir = -tangential_dir
                
                tangential_force = TANGENTIAL_GAIN * repulsion_magnitude * (tangential_dir / np.linalg.norm(tangential_dir))
                net_repulsive_vector += (radial_repulsive_force + tangential_force)

        return attractive_vector + net_repulsive_vector

    def _world_to_robot_frame(self, vector: np.ndarray, robot_theta_deg: float) -> tuple[float, float]:
        theta_rad = np.deg2rad(-robot_theta_deg)
        c, s = np.cos(theta_rad), np.sin(theta_rad)
        
        vx_world, vy_world = vector[0], vector[1]
        
        vx_robot = c * vx_world + s * vy_world
        vy_robot = -s * vx_world + c * vy_world
        
        return vx_robot, vy_robot
        
    def _cap_speed(self, vx: float, vy: float) -> tuple[float, float]:
        speed = np.sqrt(vx**2 + vy**2)
        if speed > self.MAX_LINEAR_SPEED:
            scale_factor = self.MAX_LINEAR_SPEED / speed
            return vx * scale_factor, vy * scale_factor
        return vx, vy

class Strat(Node):
    def __init__(self):
        super().__init__('strat')
        self.skills = SkillLib()
        
        self.field_subscriber = self.create_subscription(FieldData, 'field_data', self.gpCB, 10)
        self.settings_subscriver = self.create_subscription(Settings, 'settings', self.settingsCB, 10)
        
        self.cmd_publishers = {
            0: self.create_publisher(LowCmd, '/low0', 10),
            1: self.create_publisher(LowCmd, '/low1', 10),
            2: self.create_publisher(LowCmd, '/low2', 10)
        }
        
        self.get_logger().info("Strategist node initialized.")
        self.cmds = [None, None, None]
        self.timer = self.create_timer(0.1, self.send)
 
    def settingsCB(self, msg: Settings):
        global TEAM_GOAL, OP_GOAL, ATTRACTIVE_GAIN, REPULSIVE_GAIN, REPULSION_RADIUS, TANGENTIAL_GAIN, GOAL_TOLERANCE
        if msg.team_side:
            TEAM_GOAL = np.array([-FIELD_LENGTH / 2, 0.0])
            OP_GOAL = np.array([FIELD_LENGTH / 2, 0.0])
        else:
            TEAM_GOAL = np.array([FIELD_LENGTH / 2, 0.0])
            OP_GOAL = np.array([-FIELD_LENGTH / 2, 0.0])

        ATTRACTIVE_GAIN = msg.attractive_gain
        REPULSIVE_GAIN = msg.repulsive_gain
        REPULSION_RADIUS = msg.repulsion_gain
        TANGENTIAL_GAIN = msg.tangential_gain
        GOAL_TOLERANCE = msg.goal_tolerance

    def send(self):
        for i, cmd in enumerate(self.cmds):
            if cmd is not None:
                self.cmd_publishers[i].publish(cmd)

    def gpCB(self, field: FieldData):       
        target_coords = np.array([0, 0])
        target_angle = 0.0

        command = self.skills.moveToPoint(field.team0, target_coords, target_angle, [])
        self.cmds[0] = command

        command = self.skills.moveToPoint(field.team1, np.array([3, -3]), 90., [])
        self.cmds[1] = command

        
        """
        # Ejemplo 3: Los ejemplos 1 y 2 juntos, ademas de que el robot1 sigue la pelota
        r0_target_coords = np.array([0, 0])
        r0_target_angle = 45.0
        r0_command = self.skills.moveToPoint(field.robot0, r0_target_coords , r0_target_angle, [])

        r2_target_coords = np.array([3, -5])
        r2_target_angle = 0.0
        all_robots = [field.robot0, field.robot1, field.robot2, field.robot3, field.robot4, field.robot5]
        obstacles = []
        for robot in all_robots:
            if robot != field.robot2:
                obstacle = Obstacle(robot.x, robot.y)
                obstacles.append(obstacle)
        r2_command = self.skills.moveToPoint(field.robot2, r2_target_coords, r2_target_angle, obstacles)

        # El objetivo es donde sea que este la pelota
        r1_target_coords = np.array([field.ball.x+1, field.ball.y])
        r1_target_angle = -90.0
        obstacles = []
        for robot in all_robots:
            if robot != field.robot1:
                obstacle = Obstacle(robot.x, robot.y)
                obstacles.append(obstacle)
        r1_command = self.skills.moveToPoint(field.robot1, r1_target_coords, r1_target_angle, obstacles)

        # Comunicar los comandos a los 3 robots
        self.cmd_publishers[0].publish(r0_command)
        self.cmd_publishers[1].publish(r1_command)
        self.cmd_publishers[2].publish(r2_command)
        """

        return

def main(args=None):
    rclpy.init(args=args)
    node = Strat()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()